/*============================================================================
Filename : touch.h
Project : QTouch Modular Library
Purpose : configuation macros for touch library

This file is part of QTouch Modular Library Release 7.5 application.

Important Note: Do not edit this file manually.
                Use QTouch Configurator within Atmel Start to apply any
                modifications to this file.

Usage License: Refer license.h file for license information
Support: Visit http://www.microchip.com/support/hottopics.aspx
               to create MySupport case.

------------------------------------------------------------------------------
Copyright (c) 2021 Microchip. All rights reserved.
------------------------------------------------------------------------------
============================================================================*/

#ifndef TOUCH_H
#define TOUCH_H

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/*----------------------------------------------------------------------------
 *     include files
 *----------------------------------------------------------------------------*/

#include "qtouch/lib/tswrapper.h"
#include "rtc.h"

/**********************************************************/
/******************* Acquisition controls *****************/
/**********************************************************/
/* Defines the Measurement Time in milli seconds.
 * Range: 1 to 255.
 * Default value: 20.
 */
#define DEF_TOUCH_MEASUREMENT_PERIOD_MS 10

/* Defines the Measurement Time in milli seconds.
 * Range: support[2, 4, 8, 16, 32, 64, 128, 256]
 * Default value 64
 * value 0 mean never measured in idle
 */
#define DEF_TOUCH_MEASUREMENT_IDLE_PERIOD_MS 64

/* Defines the Type of sensor
 * Default value: NODE_MUTUAL.
 */
#define DEF_SENSOR_TYPE NODE_SELFCAP_SHIELD

/* Set sensor calibration mode for charge share delay ,Prescaler or series resistor.
 * Range: CAL_AUTO_TUNE_NONE / CAL_AUTO_TUNE_RSEL / CAL_AUTO_TUNE_PRSC / CAL_AUTO_TUNE_CSD
 * Default value: CAL_AUTO_TUNE_NONE.
 */
#define DEF_PTC_CAL_OPTION CAL_AUTO_TUNE_NONE

/* Defines the interrupt priority for the PTC. Set low priority to PTC interrupt for applications having interrupt time
 * constraints. Range: 0 to 2 Default: 2 (Lowest Priority)
 */
#define DEF_PTC_INTERRUPT_PRIORITY None

/* Calibration option to ensure full charge transfer */
/* Bits 7:0 = XX | TT SELECT_TAU | X | CAL_OPTION */
#define DEF_PTC_TAU_TARGET CAL_CHRG_5TAU
#define DEF_PTC_CAL_AUTO_TUNE (uint8_t)((DEF_PTC_TAU_TARGET << CAL_CHRG_TIME_POS) | DEF_PTC_CAL_OPTION)

/*----------------------------------------------------------------------------
 *     defines
 *----------------------------------------------------------------------------*/

/*
	Pin map when QT8 connected to EXT1

	QT8				EXT Board		Nano		PTC
	Y9:				EX3					PD7			XY(23)
	Y8:				EX1					PA4			XY(4)
	Y7:				EX7					PD6			XY(22)
	Y6:				EX2					PD5			XY(21)
	Y5:				EX4					PD0			XY(16)
	Y4:				EX6					PA6			XY(6)
	Y3:				EX8					PD1			XY(17)
	Y2:				EX10				PD3			XY(19)
	Y1:				EX9					PA7			XY(7)
	Y0-17:		EX11				PD2			XY(18)	--- if J2 jumped down(default)
	Y0-5:			EX5					PA5			XY(5)		--- if J2 jumped up
	DS:				EX12				PD4			XY(20)
*/

#define DS	XY(20)
#define S0	XY(18)
#define S1	XY(7)
#define S2	XY(19)
#define S3	XY(17)
#define S4	XY(6)
#define S5	XY(16)
#define S6	XY(21)
#define S7	XY(22)
#define S8	XY(4)
#define S9	XY(23)

/**********************************************************/
/***************** Node Params   ******************/
/**********************************************************/
/* Acquisition Set 1 */
/* Defines the number of sensor nodes in the acquisition set
 * Range: 1 to 65535.
 * Default value: 1
 */
#define DEF_NUM_CHANNEL_NODES (10)

/* Defines mutual cap node parameter setting
 * {X-line, Y-line, Charge Share Delay, NODE_RSEL_PRSC(series resistor, prescaler), NODE_G(Analog Gain , Digital Gain),
 * filter level}
 */
 
/* Defines node parameter setting
 * {Shield line, Y-line, Charge Share Delay, Prescaler, NODE_G(Analog Gain , Digital Gain), filter level}
 */
#if (DEF_SENSOR_TYPE == NODE_SELFCAP_SHIELD)
#define NODE_0_PARAMS                                                                                                  \
	{                                                                                                                  \
		DS /*|S0*/ |S1 |S2 |S3 |S4 |S5 |S6 |S7 |S8 |S9, S0, 0, PRSC_DIV_SEL_8,           \
		    NODE_GAIN(GAIN_1, GAIN_2), FILTER_LEVEL_16                                                                 \
	}
#define NODE_1_PARAMS                                                                                                  \
	{                                                                                                                  \
		DS |S0 /*|S1*/ |S2 |S3 |S4 |S5 |S6 |S7 |S8 |S9, S1, 0, PRSC_DIV_SEL_8,           \
		    NODE_GAIN(GAIN_1, GAIN_2), FILTER_LEVEL_16                                                                 \
	}
#define NODE_2_PARAMS                                                                                                  \
	{                                                                                                                  \
		DS |S0 |S1 /*|S2*/ |S3 |S4 |S5 |S6 |S7 |S8 |S9, S2, 0, PRSC_DIV_SEL_8,           \
		    NODE_GAIN(GAIN_1, GAIN_2), FILTER_LEVEL_16                                                                 \
	}
#define NODE_3_PARAMS                                                                                                  \
	{                                                                                                                  \
		DS |S0 |S1 |S2 /*|S3*/ |S4 |S5 |S6 |S7 |S8 |S9, S3, 0, PRSC_DIV_SEL_8,           \
		    NODE_GAIN(GAIN_1, GAIN_2), FILTER_LEVEL_16                                                                 \
	}
#define NODE_4_PARAMS                                                                                                  \
	{                                                                                                                  \
		DS |S0 |S1 |S2 |S3 /*|S4*/ |S5 |S6 |S7 |S8 |S9, S4, 0, PRSC_DIV_SEL_8,           \
		    NODE_GAIN(GAIN_1, GAIN_2), FILTER_LEVEL_16                                                                 \
	}
#define NODE_5_PARAMS                                                                                                  \
	{                                                                                                                  \
		DS |S0 |S1 |S2 |S3 |S4 /*|S5*/ |S6 |S7 |S8 |S9, S5, 0, PRSC_DIV_SEL_8,           \
		    NODE_GAIN(GAIN_1, GAIN_2), FILTER_LEVEL_16                                                                 \
	}
#define NODE_6_PARAMS                                                                                                  \
	{                                                                                                                  \
		DS |S0 |S1 |S2 |S3 |S4 |S5 /*|S6*/ |S7 |S8 |S9, S6, 0, PRSC_DIV_SEL_8,           \
		    NODE_GAIN(GAIN_1, GAIN_2), FILTER_LEVEL_16                                                                 \
	}
#define NODE_7_PARAMS                                                                                                  \
	{                                                                                                                  \
		DS |S0 |S1 |S2 |S3 |S4 |S5 |S6 /*|S7*/ |S8 |S9, S7, 0, PRSC_DIV_SEL_8,           \
		    NODE_GAIN(GAIN_1, GAIN_2), FILTER_LEVEL_16                                                                 \
	}
#define NODE_8_PARAMS                                                                                                  \
	{                                                                                                                  \
		DS |S0 |S1 |S2 |S3 |S4 |S5 |S6 |S7 /*|S8*/ |S9, S8, 0, PRSC_DIV_SEL_8,           \
		    NODE_GAIN(GAIN_1, GAIN_2), FILTER_LEVEL_16                                                                 \
	}
#define NODE_9_PARAMS                                                                                                  \
	{                                                                                                                  \
		DS |S0 |S1 |S2 |S3 |S4 |S5 |S6 |S7 |S8 /*|S9*/, S9, 0, PRSC_DIV_SEL_8,           \
		    NODE_GAIN(GAIN_1, GAIN_2), FILTER_LEVEL_16                                                                 \
	}
#elif (DEF_SENSOR_TYPE == NODE_MUTUAL)
#define NODE_0_PARAMS                                                                                                  \
	{                                                                                                                  \
		S5 |S6 |S7 |S8 |S9, S0, 0, PRSC_DIV_SEL_8,           \
		    NODE_GAIN(GAIN_1, GAIN_2), FILTER_LEVEL_16                                                                 \
	}
#define NODE_1_PARAMS                                                                                                  \
	{                                                                                                                  \
		S5 |S6 |S7 |S8 |S9, S1, 0, PRSC_DIV_SEL_8,           \
		    NODE_GAIN(GAIN_1, GAIN_2), FILTER_LEVEL_16                                                                 \
	}
#define NODE_2_PARAMS                                                                                                  \
	{                                                                                                                  \
		S5 |S6 |S7 |S8 |S9, S2, 0, PRSC_DIV_SEL_8,           \
		    NODE_GAIN(GAIN_1, GAIN_2), FILTER_LEVEL_16                                                                 \
	}
#define NODE_3_PARAMS                                                                                                  \
	{                                                                                                                  \
		S5 |S6 |S7 |S8 |S9, S3, 0, PRSC_DIV_SEL_8,           \
		    NODE_GAIN(GAIN_1, GAIN_2), FILTER_LEVEL_16                                                                 \
	}
#define NODE_4_PARAMS                                                                                                  \
	{                                                                                                                  \
		S5 |S6 |S7 |S8 |S9, S4, 0, PRSC_DIV_SEL_8,           \
		    NODE_GAIN(GAIN_1, GAIN_2), FILTER_LEVEL_16                                                                 \
	}
#define NODE_5_PARAMS                                                                                                  \
	{                                                                                                                  \
		S0 |S1 |S2 |S3 |S4, S5, 0, PRSC_DIV_SEL_8,           \
		    NODE_GAIN(GAIN_1, GAIN_2), FILTER_LEVEL_16                                                                 \
	}
#define NODE_6_PARAMS                                                                                                  \
	{                                                                                                                  \
		S0 |S1 |S2 |S3 |S4, S6, 0, PRSC_DIV_SEL_8,           \
		    NODE_GAIN(GAIN_1, GAIN_2), FILTER_LEVEL_16                                                                 \
	}
#define NODE_7_PARAMS                                                                                                  \
	{                                                                                                                  \
		S0 |S1 |S2 |S3 |S4, S7, 0, PRSC_DIV_SEL_8,           \
		    NODE_GAIN(GAIN_1, GAIN_2), FILTER_LEVEL_16                                                                 \
	}
#define NODE_8_PARAMS                                                                                                  \
	{                                                                                                                  \
		S0 |S1 |S2 |S3 |S4, S8, 0, PRSC_DIV_SEL_8,           \
		    NODE_GAIN(GAIN_1, GAIN_2), FILTER_LEVEL_16                                                                 \
	}
#define NODE_9_PARAMS                                                                                                  \
	{                                                                                                                  \
		S0 |S1 |S2 |S3 |S4, S9, 0, PRSC_DIV_SEL_8,           \
		    NODE_GAIN(GAIN_1, GAIN_2), FILTER_LEVEL_16                                                                 \
	}
#else
#error "Unsupport sensor type `DEF_SENSOR_TYPE`"
#endif

#define PTC_SEQ_NODE_CFG1	{	\
	NODE_0_PARAMS,	NODE_1_PARAMS,	NODE_2_PARAMS,	NODE_3_PARAMS,	NODE_4_PARAMS, \
	NODE_5_PARAMS,	NODE_6_PARAMS,	NODE_7_PARAMS,	NODE_8_PARAMS,	NODE_9_PARAMS \
}

/**********************************************************/
/***************** Key Params   ******************/
/**********************************************************/
/* Defines the number of key sensors
 * Range: 1 to 65535.
 * Default value: 1
 */
#define DEF_NUM_SENSORS (DEF_NUM_CHANNEL_NODES)

/* Defines Key Sensor setting
 * {Sensor Threshold, Sensor Hysterisis, Sensor AKS}
 */
#define KEY_0_PARAMS                                                                                                   \
	{                                                                                                                  \
		20, HYST_25, AKS_GROUP_1                                                                                       \
	}


#define QTLIB_KEY_CONFIGS_SET {	\
	KEY_0_PARAMS, KEY_0_PARAMS, KEY_0_PARAMS, KEY_0_PARAMS, KEY_0_PARAMS, \
	KEY_0_PARAMS, KEY_0_PARAMS, KEY_0_PARAMS, KEY_0_PARAMS, KEY_0_PARAMS \
}

/* De-bounce counter for additional measurements to confirm touch detection
 * Range: 0 to 255.
 * Default value: 4.
 */
#define DEF_TOUCH_DET_INT 4

/* De-bounce counter for additional measurements to confirm away from touch signal
 * to initiate Away from touch re-calibration.
 * Range: 0 to 255.
 * Default value: 5.
 */
#define DEF_ANTI_TCH_DET_INT 200

/* Threshold beyond with automatic sensor recalibration is initiated.
 * Range: RECAL_100/ RECAL_50 / RECAL_25 / RECAL_12_5 / RECAL_6_25 / MAX_RECAL
 * Default value: RECAL_100.
 */
#define DEF_ANTI_TCH_RECAL_THRSHLD RECAL_100

/* Rate at which sensor reference value is adjusted towards sensor signal value
 * when signal value is greater than reference.
 * Units: 200ms
 * Range: 0-255
 * Default value: 20u = 4 seconds.
 */
#define DEF_TCH_DRIFT_RATE 1

/* Rate at which sensor reference value is adjusted towards sensor signal value
 * when signal value is less than reference.
 * Units: 200ms
 * Range: 0-255
 * Default value: 5u = 1 second.
 */
#define DEF_ANTI_TCH_DRIFT_RATE 1

/* Time to restrict drift on all sensor when one or more sensors are activated.
 * Units: 200ms
 * Range: 0-255
 * Default value: 20u = 4 seconds.
 */
#define DEF_DRIFT_HOLD_TIME 2

/* Set mode for additional sensor measurements based on touch activity.
 * Range: REBURST_NONE / REBURST_UNRESOLVED / REBURST_ALL
 * Default value: REBURST_UNRESOLVED
 */
#define DEF_REBURST_MODE REBURST_UNRESOLVED

/* Sensor maximum ON duration upon touch.
 * Range: 0-255
 * Default value: 0
 */
#define DEF_MAX_ON_DURATION 250 //200ms

/**********************************************************/
/***************** Surface Parameters ****************/
/**********************************************************/

/*  Config:  */
/* Horizontal Start Key <0-65534>
 * Start key of horizontal axis
 * Range: 0 to 65534
 */
#define SURFACE_CS_START_KEY_H 5
/* Horizontal Number of Channel <0-255>
 * Number of Channels forming horizontal axis
 * Range: 0 to 255
 */
#define SURFACE_CS_NUM_KEYS_H 5
/* Vertical Start Key <0-65534>
 * Start key of vertical axis
 * Range: 0 to 65534
 */
#define SURFACE_CS_START_KEY_V 0
/* Vertical Number of Channel <0-255>
 * Number of Channels forming vertical axis
 * Range: 0 to 255
 */
#define SURFACE_CS_NUM_KEYS_V 5
/*  Position Resolution and Deadband Percentage
 *  Full scale position resolution reported for the axis and the deadband Percentage
 *  RESOL_2_BIT - RESOL_12_BIT
 *  DB_NONE - DB_15_PERCENT
 */
#define SURFACE_CS_RESOL_DB SCR_RESOL_DEADBAND(RESOL_12_BIT, DB_1_PERCENT)
/* Median filter enable and  IIR filter Config
 * Median Filter <0-1>
 * Enable or Disable Median Filter
 * enable - 1
 * disable - 0
 * IIR filter <0-3>
 * Configure IIR filter
 *  0 - None
 *  1 - 25%
 *  2 - 50%
 *  3 - 75%
 */
#define SURFACE_CS_FILT_CFG SCR_MEDIAN_IIR(1, 3)
/* Position Hystersis <0-255>
 * The minimum travel distance to be reported after contact or direction change
 * Applicable to Horizontal and Vertical directions
 */
#define SURFACE_CS_POS_HYST 3
/* Minimum Contact <0-65534>
 * The minimum contact size measurement for persistent contact tracking.
 * Contact size is the sum of neighbouring keys' touch deltas forming the touch contact.
 */
#define SURFACE_CS_MIN_CONTACT 60

/**********************************************************/
/***************** Gesture Parameters ****************/
/**********************************************************/

/*	Tap Release timeout  <3-255>
 *	The TAP_RELEASE_TIMEOUT parameter limits the amount of time allowed between the initial finger press and the
 *liftoff. Exceeding this value will cause the firmware to not consider the gesture as a tap gesture.
 *  TAP_RELEASE_TIMEOUT should be lesser than the TAP_HOLD_TIMEOUT and SWIPE_TIMEOUT.
 *  Unit: x10 ms
 *  Example: if TAP_RELEASE_TIMEOUT is configured as 3, then the user should finish tapping within 30 ms to qualify the
 *gesture as tap.
 */
#define TAP_RELEASE_TIMEOUT 20
/*  Tap Hold timeout <0-255>
 *	If a finger stays within the bounds set by TAP_AREA and is not removed, the firmware will report a Tap Hold gesture
 *once the gesture timer exceeds the TAP_HOLD_TIMEOUT value. HOLD_TAP is a single finger gesture whereas HOLD_TAP_DUAL
 *is dual finger gesture. Ideally, TAP_HOLD_TIMEOUT should be greater than the TAP_RELEASE_TIMEOUT and SWIPE_TIMEOUT.
 *  Unit: x10 ms
 *  Example: if TAP_HOLD_TIMEOUT is configured as 6, then the user should tap and hold inside the TAP_AREA for 60 ms to
 *qualify the gesture as tap and hold.
 */
#define TAP_HOLD_TIMEOUT 100
/*  Swipe timeout <0-255>
 *	The SWIPE_TIMEOUT limits the amount of time allowed for the swipe gesture (initial finger press, moving in a
 *particular direction crossing the distance threshold and the liftoff). Ideally, SWIPE_TIMEOUT should be greater than
 *TAP_RELEASE_TIMEOUT but smaller than the TAP_HOLD_TIMEOUT. Unit: x10 ms Example: if SWIPE_TIMEOUT is configured as 5,
 *then the user should swipe in a particular direction and liftoff within 50 ms to qualify the gesture as swipe.
 */
#define SWIPE_TIMEOUT 70
/*  Horizontal Swipe distance threshold <0-255>
 *	HORIZONTAL_SWIPE_DISTANCE_THRESHOLD controls the distance travelled in the X axis direction for detecting Left and
 *Right Swipe gestures. Unit: X-coordinate Example: If HORIZONTAL_SWIPE_DISTANCE_THRESHOLD is configured as 50, and a
 *user places their finger at x-coordinate 100, they must move to at least x-coordinate 50 to record a left swipe
 *gesture.
 */
#define HORIZONTAL_SWIPE_DISTANCE_THRESHOLD 30
/* 	Vertical swipe distance threshold <0-255>
 *	VERTICAL_SWIPE_DISTANCE_THRESHOLD controls the distance travelled in the Y axis direction for detecting Up and Down
 *Swipe gestures. Unit: Y-coordinate Example: if VERTICAL_SWIPE_DISTANCE_THRESHOLD is configured as 30, and a user
 *places their finger at y-coordinate 100, they must move to at least y-coordinate 70 to record a down swipe gesture.
 */
#define VERTICAL_SWIPE_DISTANCE_THRESHOLD 30
/* 	Tap area <0-255>
 *	The TAP_AREA bounds the finger to an area it must stay within to be considered a tap gesture when the finger is
 *removed and tap and hold gesture if the finger is not removed for sometime. Unit: coordinates Example: if TAP_AREA is
 *configured as 20, then user should tap within 20 coordinates to detect the tap gesture.
 */
#define TAP_AREA 20
/* 	Seq Tap distance threshold <0-255>
 *	The SEQ_TAP_DIST_THRESHOLD parameter limits the allowable distance of the current touch's initial press from the
 *liftoff position of the previous touch. It is used for multiple taps (double-tap, triple-tap etc). If the taps
 *following the first are within this threshold, then the tap counter will be incremented. If the following tap
 *gestures exceed this threshold, the previous touch is sent as a single tap and the current touch will reset the tap
 *counter. Unit: coordinates Example: if SEQ_TAP_DIST_THRESHOLD is configured as 20, after the first tap, if the user
 *taps again within 20 coordinates, it is considered as double tap gesture.
 */
#define SEQ_TAP_DIST_THRESHOLD 50
/* 	Edge Boundary <0-255>
 *	The firmware can also be modified to define an edge region along the border of the touch sensor.
 *	With Edge Boundary defined, swipe gestures that start in an edge region will be reported as edge swipe gestures in
 *place of normal swipe gestures. To create an edge region, the EDGE_BOUNDARY is set with the size (in touch
 *coordinates) of the edge region. Unit: coordinates Example: Setting the EDGE_BOUNDARY parameter to 100 will designate
 *the area 100 units in from each edge as the edge region.
 */
#define EDGE_BOUNDARY 0
/*  Wheel Post-scaler <0-255>
 *	The clockwise wheel is performed with 4 swipes (right->down->left->up). Similarly, the anti-clockwise wheel is
 *performed with 4 swipes (left->down->right->up). To detect a wheel, the minimum number of swipe required is wheel
 *start quadrant count + wheel post scaler. Once the wheel is detected, for post scaler number of swipe detections, the
 *wheel counter will be incremented by 1. Example: if wheel post scaler is 2, then for each two swipe detection, the
 *wheel counter will be incremented by 1.
 */
#define WHEEL_POSTSCALER 1
/* 	Wheel Start Quadrant count <2-255>
 *	The wheel gesture movement can be broken down into 90 degree arcs.
 *	The firmware watches for a certain number of arcs to occur in a circular pattern before starting to report wheel
 *gesture information. The number of arcs that must be first detected is determined by the WHEEL_START_QUADRANT_COUNT
 *parameter. Lower values for this parameter make it faster to start a wheel gesture, but it also makes the firmware
 *prone to prematurely reporting wheel gesture information. Example: if WHEEL_START_QUADRANT_COUNT is configured as 2,
 *then after 180 degree, the gesture is updated as Wheel.
 */
#define WHEEL_START_QUADRANT_COUNT 2
/* 	Wheel Reverse Quadrant count <2-255>
 *	The WHEEL_REVERSE_QUADRANT_COUNT performs a similar function as WHEEL_START_QUADRANT_COUNT except it is used when
 *changing the direction of the wheel instead of starting it new. This is used to prevent quick toggling between
 *directions. Example: If WHEEL_REVERSE_QUADRANT_COUNT is set as 4 and after some wheel gestures, if the user changes
 *the direction of rotation, then only after 360 degree, it will be detected as one wheel gesture.
 */
#define WHEEL_REVERSE_QUADRANT_COUNT 2

/* Pinch Zoom Threshold <0-255>
 * The PINCH_ZOOM_THRESHOLD limits the allowable distance between the two fingers to detect the pinch and the zoom
 * gestures. After crossing the PINCH_ZOOM_THRESHOLD, if the distance between the contacts is reducing, then the gesture
 * is reported as 'PINCH'. After crossing the PINCH_ZOOM_THRESHOLD, if the distance between the contacts is increasing,
 * then the gesture is reported as 'ZOOM'. Unit: coordinates Example: if PINCH_ZOOM_THRESHOLD is configured as 20, then
 * after crossing 20 coordinates, it will be reported as the pinch gesture or the zoom gesture.
 */
#define PINCH_ZOOM_THRESHOLD 150

#define DEF_GESTURE_TIME_BASE_MS 10u

/**********************************************************/
/********* Frequency Hop Module ****************/
/**********************************************************/

#define DEF_SEL_FREQ_INIT FREQ_SEL_0

/* sets the frequency steps for hop.
 * Range: 3 to 7.
 * Default value: 3
 */
#define NUM_FREQ_STEPS 3

/* ADC Sampling Delay Selection - 0 to 15 (100ns unit) cycles */
#define DEF_MEDIAN_FILTER_FREQUENCIES FREQ_SEL_0, FREQ_SEL_7, FREQ_SEL_15

/**********************************************************/
/******************* Low-power parameters *****************/
/**********************************************************/
/* Enable or disable low-power scan
 * Range: 0 or 1
 * Default value: 1
 */
#ifdef OBJECT_T126
#define DEF_TOUCH_LOWPOWER_ENABLE 1u
#endif

/* Node selection for Low-power scan.
 * Range: 0 to (DEF_NUM_CHANNELS-1).
 * Default value: 0
 */
#define QTM_AUTOSCAN_NODE 0

/* Touch detection threshold for Low-power node.
 * Range: 10 to 255
 * Default value: 10
 */
#define QTM_AUTOSCAN_THRESHOLD 100

/* Defines the Auto scan trigger period.
 * The Low-power measurement period determine the interval between low-power touch measurement.
 * Range: NODE_SCAN_4MS to NODE_SCAN_4096MS
 * Default value: NODE_SCAN_64MS
 */
#define QTM_AUTOSCAN_TRIGGER_PERIOD NODE_SCAN_32MS

/* Waiting time (in millisecond) for the application to switch to low-power measurement after the last touch.
 * Range: 0 to 255, unit 200ms
 * Default value: 0(never timeout)
 */
#define DEF_TOUCH_ACTIVE_IDLE_TIMEOUT 0

/* Defines drift measurement period
 * During low-power measurement, it is recommended to perform periodic active measurement to perform drifting.
 * This parameter defines the measurement interval to perform drifting.
 * Range: 0 to 255 ( should be more than QTM_AUTOSCAN_TRIGGER_PERIOD) unit 200ms
	0: never drift
   Note: the maximum value will be limited by WDTDOG setting
 */
#define DEF_TOUCH_DRIFT_PERIOD_MS 20

/* Defines overflow measage of the measurement
 * During measurement, acquisition should be done before next measurement. If not, that means sampling interval is two fast or something wrong of the measurement
 * Range: count that notice overflow
	0 ~ 255
 */
#ifdef DEF_TOUCH_MEASUREMENT_OVERFLOW
#define DEF_TOUCH_MEASUREMENT_OVERFLOW_THRESHOLD 4
#define DEF_TOUCH_MEASUREMENT_OVERFLOW_FORCE_DONE 200
#endif

/**********************************************************/
/***************** Communication - Data Streamer ******************/
/**********************************************************/

#define DATA_STREAMER_BOARD_TYPE USER_BOARD

/**********************************************************/
/***************** Communication - Surface Utility ******************/
/**********************************************************/

#ifdef __cplusplus
}
#endif // __cplusplus
#endif // TOUCH_C
